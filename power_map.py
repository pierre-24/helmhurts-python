"""
Compute the field generated by a Wi-Fi (or any other equipment that emits E.M. wave in the GHz range).

Expects an image as input,
where the color of the wall is given by `--wall-color-in` (default = black), and
the color of the source is given by `--source-color-in` (default = red).
"""

__version__ = '0.1'

import numpy
from PIL import Image
import argparse

from helmhurts.solver_system import HelmholtzSolverDirichletSystem

SPEED_OF_LIGHT = 299_792_458  # m/s


def power_color_map(shape: tuple, map_in: numpy.ndarray, cmax=2) -> numpy.ndarray:
    """Create a power map from `map_in`: [0,0.5) -> blue, (.5,1] -> white.
    """

    array_out = numpy.zeros(shape, dtype=numpy.uint8)
    for i in range(3):
        if i == cmax:
            array_out[:, :, i] = numpy.where(map_in < .5, 255 * map_in, 255)
        else:
            array_out[:, :, i] = numpy.where(map_in > .5, 255 * (map_in - .5) * 2, 0)

    return array_out


def logical_and(*conds):
    """Chain conditions with AND"""
    land = numpy.logical_and(conds[0], conds[1])
    for c in conds[2:]:
        land = numpy.logical_and(land, c)

    return land


def logical_or(*conds):
    """Chain conditions with OR"""
    lor = numpy.logical_or(conds[0], conds[1])
    for c in conds[2:]:
        lor = numpy.logical_or(lor, c)

    return lor


def t_color(in_str: str):
    components = in_str.split(',')
    if len(components) != 3:
        raise argparse.ArgumentTypeError('must be a triplet')

    try:
        color = tuple(int(i) for i in components)
    except ValueError:
        raise argparse.ArgumentTypeError('must be a triplet of int')

    if not all(0 <= i < 256 for i in color):
        raise argparse.ArgumentTypeError('component of color must be in [0,255]')

    return color


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__)

    parser.add_argument('input', type=str, help='Map of the walls')

    parser.add_argument('-m', '--min', type=float, help='Floor value of power (in dB)', default=-100)
    parser.add_argument('-M', '--max', type=float, help='ceil value of power (in dB)', default=-70)
    parser.add_argument('-p', '--power', type=float, help='power of the source (in V/m²?)', default=1)
    parser.add_argument('-f', '--frequency', type=float, help='frequency of the wave (in GHz)', default=2.4)
    parser.add_argument('-r', '--resolution', type=float, help='spacial resolution (in m)', default=0.01)
    parser.add_argument('-w', '--wall-refractive', type=float, help='refractive index of the walls', default=2.24)
    parser.add_argument('-d', '--wall-diffusive', type=float, help='diffusive power of wall (in S/m)', default=0.1)

    parser.add_argument(
        '--alayer-thickness', type=int, help='thickness of absorption layer', default=12)
    parser.add_argument(
        '--alayer-diffusive', type=float, help='diffusive power of absorption layer (in S/m)', default=1.0)

    parser.add_argument('--wall-color-in', type=t_color, help='color of the walls in input', default='0,0,0')
    parser.add_argument(
        '--wall-color-out', type=t_color, help='color of the contour of the walls in output', default='255,255,255')
    parser.add_argument('--source-color-in', type=t_color, help='color of the sources in input', default='255,0,0')
    parser.add_argument('--source-color-out', type=t_color, help='color of the sources in output', default='255,0,0')

    parser.add_argument('--power-map-c', type=int, help='map color shade', default=1)

    args = parser.parse_args()
    im = numpy.array(Image.open(args.input))
    sz = im.shape[:2]

    # create diffraction map
    n = numpy.ones(sz, dtype=complex)
    wall_refractive_index = args.wall_refractive + 1j * args.wall_diffusive
    wall_mask = logical_and(
        im[:, :, 0] == args.wall_color_in[0],
        im[:, :, 1] == args.wall_color_in[1],
        im[:, :, 2] == args.wall_color_in[2]
    )

    n[wall_mask] = wall_refractive_index

    # create source map
    s = numpy.zeros(sz)
    s[logical_and(
        im[:, :, 0] == args.source_color_in[0],
        im[:, :, 1] == args.source_color_in[1],
        im[:, :, 2] == args.source_color_in[2]
    )] = args.power

    # solve
    k = 2 * numpy.pi * args.frequency * 1e9 / SPEED_OF_LIGHT  # k = 2π/λ and λ = c/f, so k = 2πf/c
    print('f = {:.3f} GHz → λ = {:.4f}m → k = {:.3f}'.format(
        args.frequency, SPEED_OF_LIGHT / (args.frequency * 1e9), k))

    solver = HelmholtzSolverDirichletSystem(
        k, n, s, (args.resolution, args.resolution), args.alayer_thickness, args.alayer_diffusive)
    print('Computing ...', end='')
    E = solver.compute_E()
    print(' done!')

    # create power map output
    Ep = (20 * numpy.log10(numpy.abs(E)) - args.min) / numpy.fabs(args.min - args.max)
    Ep[Ep < 0] = .0
    Ep[Ep > 1] = 1.

    im_gradient = numpy.array(numpy.gradient(im[:, :, 0]))

    array_out = power_color_map((im.shape[0], im.shape[1], 3), Ep, cmax=args.power_map_c)
    array_out[
        numpy.logical_and(
            logical_or(im_gradient[0] > 10, im_gradient[0] < -10, im_gradient[1] > 10, im_gradient[1] < -10),
            wall_mask
        ), :] = args.wall_color_out  # wall

    array_out[logical_and(
        im[:, :, 0] == args.source_color_in[0],
        im[:, :, 1] == args.source_color_in[1],
        im[:, :, 2] == args.source_color_in[2]
    ), :] = args.source_color_out  # source

    im_out = Image.fromarray(array_out, 'RGB')
    im_out.show()
