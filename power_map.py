"""
Compute the field generated by a Wi-Fi (or any other equipment that emits E.M. wave in the GHz range).

Expects an image as input, where
- the floor (n=1.0) is in white,
- wall (n=2.24 -0.021j) is in black, and
- emitter is in red.
"""

__version__ = '0.1'

import numpy
from PIL import Image
import argparse

from helmhurts.solver_system import HelmholtzSolverDirichletSystem

WALL_REFRACTIVE_INDEX = 2.24 - 0.021j
SPEED_OF_LIGHT = 299_792_458  # m/s


def power_color_map(shape: tuple, map_in: numpy.ndarray) -> numpy.ndarray:
    """Create a power map from `map_in`: [0,0.5) -> blue, (.5,1] -> white.
    """

    array_out = numpy.zeros(shape, dtype=numpy.uint8)
    array_out[:, :, 0] = numpy.where(map_in > .5, 255 * (map_in - .5) * 2, 0)
    array_out[:, :, 1] = numpy.where(map_in > .5, 255 * (map_in - .5) * 2, 0)
    array_out[:, :, 2] = numpy.where(map_in < .5, 255 * map_in, 255)

    return array_out


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__)

    parser.add_argument('input', type=str, help='Map of the walls')

    parser.add_argument('-m', '--min', type=float, help='Floor value of power (in dB)', default=-150)
    parser.add_argument('-M', '--max', type=float, help='ceil value of power (in dB)', default=-100)
    parser.add_argument('-p', '--power', type=float, help='power of the source (in V/m²?)', default=1)
    parser.add_argument('-f', '--frequency', type=float, help='frequency of the wave (in GHz)', default=2.4)
    parser.add_argument('-r', '--resolution', type=float, help='spacial resolution (in m)', default=0.02)

    args = parser.parse_args()
    im = numpy.array(Image.open(args.input))
    sz = im.shape[:2]

    # create diffraction map
    n = numpy.ones(sz, dtype=complex)
    n[numpy.logical_and(im[:, :, 0] == 0, im[:, :, 1] == 0)] = WALL_REFRACTIVE_INDEX

    # create source map
    f = numpy.zeros(sz)
    f[numpy.logical_and(im[:, :, 0] == 255, im[:, :, 1] == 0)] = args.power

    # solve
    print('f = {:.3f} Ghz → λ = {:.4f}m'.format(args.frequency, SPEED_OF_LIGHT / (args.frequency * 1e9)))
    k = 2 * numpy.pi * args.frequency * 1e9 / SPEED_OF_LIGHT  # k = 2π/λ and λ = c/f, so k = 2πf/c
    solver = HelmholtzSolverDirichletSystem(k, n, f, (args.resolution, args.resolution))
    print('Computing ...', end='')
    E = solver.compute_E()
    print(' done!')

    # create power map output
    Ep = (20 * numpy.log10(numpy.abs(E) ** 2) - args.min) / numpy.fabs(args.min - args.max)
    Ep[Ep < 0] = .0
    Ep[Ep > 1] = 1.

    array_out = power_color_map(im.shape, Ep)
    array_out[numpy.logical_and(im[:, :, 0] == 0, im[:, :, 1] == 0), :] = [0, 0, 0]  # wall
    array_out[numpy.logical_and(im[:, :, 0] == 255, im[:, :, 1] == 0), :] = [255, 0, 0]  # source

    im_out = Image.fromarray(array_out, 'RGB')
    im_out.show()
